<script>
function buildSrcDoc(url) {
  const preferred = localStorage.getItem('ble_proxy_pref');
  const list = [
    { build: (u) => 'https://api.allorigins.win/get?url=' + encodeURIComponent(u), mode: 'allorigins' },
    { build: (u) => 'https://thingproxy.freeboard.io/fetch/' + u, mode: 'plain' },
    { build: (u) => 'https://cors.isomorphic-git.org/' + u, mode: 'plain' },
    { build: (u) => 'https://corsproxy.io/?' + u, mode: 'plain' },
    { build: (u) => u, mode: 'plain' } // 直连（通常会失败，但保留兜底）
  ];
  const ordered = preferred ? [{ build: (u) => preferred + u, mode: 'plain' }].concat(list) : list;

  return `<!DOCTYPE html><html><body><script>
const endpoint = ${JSON.stringify(url)};
const candidates = ${JSON.stringify(ordered)}; // 已按优先级排序
const timeout = (ms) => new Promise((_, r) => setTimeout(() => r(new Error('timeout')), ms));

async function tryFetch(target, mode) {
  const p = fetch(target, { method: 'GET', cache: 'no-store', mode: 'cors', credentials: 'omit', referrerPolicy: 'no-referrer' });
  const res = await Promise.race([p, timeout(8000)]);
  if (!res.ok) throw new Error('HTTP ' + res.status);
  if (mode === 'allorigins') {
    const wrapped = await res.json();
    return JSON.parse(wrapped.contents);
  } else {
    const txt = await res.text();
    return JSON.parse(txt);
  }
}

(async () => {
  let lastErr;
  // 两轮尝试，降低首次失败概率
  for (let round = 0; round < 2; round++) {
    for (const c of candidates) {
      const base = typeof c.build === 'string' ? c.build : null;
      const tgt = base ? base + endpoint : c.build(endpoint);
      try {
        const data = await tryFetch(tgt, c.mode);
        // 记住成功代理前缀（仅限明确前缀的代理）
        if (base || tgt.startsWith('https://api.allorigins.win') || tgt.startsWith('https://thingproxy.freeboard.io/fetch/') || tgt.startsWith('https://cors.isomorphic-git.org/') || tgt.startsWith('https://corsproxy.io/?')) {
          const pref = tgt.replace(endpoint, '');
          try { parent.localStorage.setItem('ble_proxy_pref', pref); } catch {}
        }
        parent.postMessage({ type: 'json', data }, '*');
        return;
      } catch (err) { lastErr = err; }
    }
    await new Promise(r => setTimeout(r, 500));
  }
  parent.postMessage({ type: 'error', message: String(lastErr || '无法获取数据') }, '*');
})();
<\/script></body></html>`;
}
</script>
